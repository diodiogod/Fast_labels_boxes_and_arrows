<!doctype html>
<html style="height:100%;">
<head>
    <title>Tagger</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/cerulean/bootstrap.min.css" rel="stylesheet"></link>
    <style>
        body {
            margin: 0;
            height: 100%;
            overflow: hidden; /* Prevent scrolling of the body */
        }
        #sidebar {
            width: 25%;
            height: 100%;
            float: left;
            z-index: 8000;
            margin-bottom: 0px;
        }
		#content {
			width: 75%;
			height: 100%; /* Use the full height of the screen */
			float: right;
			z-index: 8000;
			margin-bottom: 0px;
			overflow: hidden;
			display: flex;           /* Flexbox layout to make the canvas fill the container */
			flex-direction: column;  /* Ensures children grow vertically */
		}

		#canvas {
			flex-grow: 1;            /* Make canvas grow to fill available space */
			width: 100%;             /* Ensure the canvas takes full width */
			height: calc(100vh - 40px); /* Use calc() to ensure full height, adjusting for any fixed controls */
			margin: 0;
			padding: 0;
			display: block;          /* Ensures the canvas behaves like a block element */
			background-color: white; /* Optional: set a background to visually confirm canvas bounds */
			cursor: crosshair; /* Set the cursor to crosshair */
		}

		
        #zoomControls {
            position: fixed;
            bottom: 0;
            width: 100%;
            background-color: #f8f9fa; /* Background color for better visibility */
            padding: 10px;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1); /* Optional shadow for better visibility */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #resizeSlider {
            width: 60%;
        }
        #debugInfo {
            position: fixed;
            top: 0;
            right: 0;
            background: #fff;
            padding: 10px;
            border: 1px solid #ddd;
            z-index: 9000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        /* Tab styling */
        .nav-tabs {
            margin-bottom: 10px;
        }
        .tab-content {
            height: calc(100% - 40px); /* Adjust to leave space for the tabs */
            overflow-y: auto;
        }
    </style>
</head>
<body>
<nav id="sidebar">
    <ul class="nav nav-tabs">
        <li class="active"><a data-toggle="tab" href="#labelsTab">Labels</a></li>
        <li><a data-toggle="tab" href="#predefinedLabelsTab">Predefined Labels</a></li>
    </ul>

    <div class="tab-content">
        <!-- Labels Tab -->
        <div id="labelsTab" class="tab-pane fade in active">
            <div class="panel panel-default" style="height: 100%;">
                <div class="panel-heading">
                    <h3 class="panel-title">Labels</h3>
					<!-- Add this inside the Predefined Labels Tab panel body -->
					<button id="toggleLabelMode" class="btn btn-info" style="width: 100%; margin-top: 10px;">Toggle to Arrow Mode</button>

                </div>
                <div class="panel-body" style="overflow-y: auto;">
                    <div class="list-group" id="labelList">
                        {% for label in labels %}
                            <div class="list-group-item">
                                <div class="input-group">
                                    <span class="input-group-addon" id="id">{{ label.id }}</span>
                                    {% if label.name %}
                                        <input type="text" value="{{ label.name }}" onchange="label('{{ label.id }}', this.value)" class="form-control" style="background-color:#E5E7E9;"></input>
                                        <span class="input-group-btn">
                                            <input type="color" class="btn btn-default" value="{{ label.color }}" onchange="changeLabelColor('{{ label.id }}', this.value)" style="width: 34px; height: 34px; padding: 0; margin-right: 5px; margin-left: 5px;">
                                            <button class="btn btn-danger" onclick="deleteLabel('{{ label.id }}')" type="button">-</button>
                                        </span>
                                    {% else %}
                                        <input id="{{ label.id }}" onkeydown="if (event.keyCode == 13) { label(this.id, this.value); }" type="text" class="form-control" placeholder="label name" autofocus></input>
                                    {% endif %}
                                </div>
                            </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>

        <!-- Predefined Labels Tab -->
		<div id="predefinedLabelsTab" class="tab-pane fade">
			<div class="panel panel-default" style="height: 100%;">
				<div class="panel-heading">
					<h3 class="panel-title">Predefined Labels</h3>
				</div>
				<div class="panel-body" style="overflow-y: auto;">
					<div id="predefinedLabelList" class="list-group">
						<!-- Predefined labels will be listed here -->
					</div>
					
					<!-- First: Label Font Size Input -->
					<label for="labelFontSizeInput">Label Font Size (% of Image Width) and Offset:</label>

					<!-- Label Font Size Slider and Input -->
					<div class="input-group" style="margin-top: 10px;">
						<span class="input-group-addon">Font Size (%):</span>
						<input type="range" id="labelFontSizeSlider" class="form-control" value="4.5" min="1" max="10" step="0.1" style="width: calc(100% - 75px);">
						<input type="number" id="labelFontSizeInput" class="form-control" value="4.5" min="1" max="100" step="0.1" style="width: 75px;">
					</div>
					
					<!-- Unified Label Offset Inputs with Font Selection Dropdown -->
					<div class="input-group" style="margin-top: 10px;">
						<span class="input-group-addon">Offset (X/Y):</span>
						<input type="number" id="labelOffsetXInput" class="form-control" value="0" step="1" style="width: 60px;">
						<input type="number" id="labelOffsetYInput" class="form-control" value="0" step="1" style="width: 60px;">

						<!-- Font Dropdown (Placed in the same input group) -->
						<span class="input-group-addon">Font:</span>
						<select id="fontSelect" class="form-control" style="width: 100%;">
							<option value="Arial">Arial</option>
							<option value="Verdana">Verdana</option>
							<option value="Courier New">Courier New</option>
							<option value="Times New Roman">Times New Roman</option>
							<option value="Georgia">Georgia</option>
							<option value="Roboto">Roboto</option>                <!-- Modern and clean font -->
							<option value="Open Sans">Open Sans</option>          <!-- Popular web font -->
							<option value="Lato">Lato</option>                    <!-- Clean and minimal font -->
							<option value="Consolas">Consolas</option>            <!-- Commonly used in code editors -->
							<option value="Monaco">Monaco</option>                <!-- Another coding font, often used on macOS -->
							<option value="Lucida Console">Lucida Console</option> <!-- Another monospaced font -->
							<option value="Source Code Pro">Source Code Pro</option> <!-- Googleâ€™s font for code -->
							<option value="Fira Code">Fira Code</option>          <!-- A font designed for coding -->
							<option value="PT Mono">PT Mono</option>              <!-- Simple, clear monospaced font -->
							<option value="Inconsolata">Inconsolata</option>      <!-- Another great option for code -->
							<option value="Raleway">Raleway</option>              <!-- Modern and elegant font -->
							<option value="Ubuntu">Ubuntu</option>                <!-- Popular in Linux environments -->
						</select>
					</div>
					
					<!-- Label arrow Size Slider and Input -->
					<div class="input-group" style="margin-top: 10px;">
						<span class="input-group-addon">Arrow Head Size (%):</span>
						<input type="range" id="arrowHeadSizeSlider" class="form-control" value="45" min="1" max="100" step="0.1" style="width: calc(100% - 75px);">
						<input type="number" id="arrowHeadSizeInput" class="form-control" value="45" min="1" max="100" step="0.1" style="width: 75px;">
					</div>
					<!-- Dropdown for selecting Arrowhead Type -->
					<div class="input-group" style="margin-top: 10px;">
						<span class="input-group-addon">Arrowhead Type:</span>
						<select id="arrowHeadTypeSelect" class="form-control">
							<option value="standard">Standard</option>
							<option value="triangle">Triangle</option>
						</select>
					</div>

					<!-- Second: Add New Label Button -->
					<button id="addPredefinedLabel" class="btn btn-success" style="width: 100%; margin-top: 10px;">Add New Label</button>

					<!-- Third: Reset to Default Button -->
					<button id="resetToDefaultPredefinedLabels" class="btn btn-warning" style="width: 100%; margin-top: 10px;">Reset to Default</button>
					
				</div>
			</div>
		</div>

    </div>
</nav>

<div id="content" class="container">

    <div style="overflow: hidden">
        <canvas id="canvas"></canvas>
    </div>
</div>
<div id="zoomControls">
    <input type="range" id="resizeSlider" min="10" max="200" value="100">
    <button id="resetButton" class="btn btn-primary">Reset to 100%</button>
    <span id="currentScale">100%</span>
    <button id="downloadButton" class="btn btn-success" style="margin-left: 10px;">Download Image</button>
	<button id="saveCsvButton" class="btn btn-warning" style="margin-left: 10px;">Save CSV</button>
</div>
<div style="position: fixed; bottom: 10px; left: 10px;">
    <!-- Previous Image Button -->
    {% if not_start %}
        <a href="/previous" class="btn btn-primary" type="button">
            <span class="glyphicon glyphicon-arrow-left"></span>
        </a>
    {% else %}
        <a href="/previous" class="btn btn-primary" type="button">
            <span class="glyphicon glyphicon-ok"> </span>
        </a>
    {% endif %}

    <!-- Next Image Button -->
    {% if not_end %}
        <a href="/next" class="btn btn-primary" type="button">
            <span class="glyphicon glyphicon-arrow-right"></span>
        </a>
    {% else %}
        <a href="/next" class="btn btn-primary" type="button">
            <span class="glyphicon glyphicon-ok"> </span>
        </a>
    {% endif %}
</div>

<script>
var labels = {{ labels|tojson|safe }};
var c = document.getElementById("canvas");
var ctx = c.getContext("2d");
var image = new Image();
var originalWidth, originalHeight;
var scale = 1;
var labelFontSizePercentage = 4.5; // Default value as 4.5%
var arrowHeadSize = 45; // Default value as 45
var labelOffsetX = 0; // Default horizontal offset (in pixels)
var labelOffsetY = 0; // Default vertical offset (in pixels)

var offsetX = 0, offsetY = 0;  // Track offsets for dragging

var predefinedLabels = [
    { name: "Apple", color: "#00FFFF" },
    { name: "Banana", color: "#FF00FF" },
    { name: "Peach", color: "#008000" },
    { name: "Grapes", color: "#FFFF00" },
    { name: "Lemon", color: "#FF0000" }
];  // Add default predefined labels or load them from localStorage

var labelFont = "Verdana"; // Default font

// Load the font selection from localStorage
function loadFontSelection() {
    const savedFont = localStorage.getItem('labelFont');
    if (savedFont) {
        labelFont = savedFont;
        document.getElementById("fontSelect").value = labelFont;
    } else {
        labelFont = "Verdana"; // Default font
    }
}

// Save the font selection to localStorage
function saveFontSelection() {
    localStorage.setItem('labelFont', labelFont);
}

// Apply the selected font to the labels
function applyFontSelection() {
    // This function will be called whenever the font is changed to redraw the canvas
    resizeCanvas();
}

// Load the font selection when the page loads
document.addEventListener('DOMContentLoaded', function() {
    loadFontSelection();
    applyFontSelection();
});

// Update the font selection when the dropdown value changes
document.getElementById("fontSelect").addEventListener("change", function() {
    labelFont = this.value;
    saveFontSelection();
    applyFontSelection();
});

document.addEventListener('DOMContentLoaded', function() {
    var savedLabelMode = localStorage.getItem('labelMode');
    if (savedLabelMode) {
        labelMode = savedLabelMode;
        document.getElementById('toggleLabelMode').textContent = 
            labelMode === 'box' ? 'Toggle to Arrow Mode' : 'Toggle to Box Mode';
    }
});

// Function to load predefined labels from localStorage or use defaults
function loadPredefinedLabels() {
    const savedPredefinedLabels = localStorage.getItem('predefinedLabels');
    if (savedPredefinedLabels) {
        predefinedLabels = JSON.parse(savedPredefinedLabels);
    } else {
        predefinedLabels = [
            { name: "Apple", color: "#00FF00" },
			{ name: "Apple", color: "#00FFFF" },
			{ name: "Banana", color: "#FF00FF" },
			{ name: "Peach", color: "#008000" },
			{ name: "Grapes", color: "#FFFF00" },
			{ name: "Lemon", color: "#FF0000" }
        ];  // Provide default labels if none are saved
    }
}

// Function to save predefined labels to localStorage
function savePredefinedLabels() {
    localStorage.setItem('predefinedLabels', JSON.stringify(predefinedLabels));
}

// Initialize predefined labels with values from localStorage if available
loadPredefinedLabels();

// Initialize the arrow head type (standard by default)
var arrowHeadType = 'standard';

function loadArrowHeadType() {
    const savedArrowHeadType = localStorage.getItem('arrowHeadType');
    if (savedArrowHeadType) {
        arrowHeadType = savedArrowHeadType;
        document.getElementById("arrowHeadTypeSelect").value = arrowHeadType;
    } else {
        arrowHeadType = 'standard'; // Default type
    }
}

document.getElementById("arrowHeadTypeSelect").addEventListener("change", function() {
    arrowHeadType = this.value;
    localStorage.setItem('arrowHeadType', arrowHeadType);
    resizeCanvas();  // Redraw the canvas with the new arrowhead type
});

// Function to draw labels (both boxes and arrows)
function drawLabels(label) {
    const { name, xMin, xMax, yMin, yMax, color, type } = label;
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = 3;

    if (type === 'box') {
        // Draw a rectangle (bounding box)
        ctx.beginPath();
        ctx.rect(xMin * scale + offsetX, yMin * scale + offsetY, (xMax - xMin) * scale, (yMax - yMin) * scale);
        ctx.stroke();
    } else if (type === 'arrow') {
        // Draw the line of the arrow
        ctx.beginPath();
        ctx.moveTo(xMin * scale + offsetX, yMin * scale + offsetY);
        ctx.lineTo(xMax * scale + offsetX, yMax * scale + offsetY);
        ctx.stroke();

        // Calculate the arrowhead
        const headlen = arrowHeadSize * scale; // Scale the arrowhead size
        const angle = Math.atan2(yMax - yMin, xMax - xMin);

        if (arrowHeadType === 'standard') {
            // Standard arrowhead
            ctx.beginPath();
            ctx.moveTo(xMin * scale + offsetX, yMin * scale + offsetY);
			ctx.lineTo(xMax * scale + offsetX, yMax * scale + offsetY);
			ctx.stroke();			

			ctx.lineTo(
				xMax * scale + offsetX - headlen * Math.cos(angle - Math.PI / 6),
				yMax * scale + offsetY - headlen * Math.sin(angle - Math.PI / 6)
			);
			ctx.moveTo(xMax * scale + offsetX, yMax * scale + offsetY);
			ctx.lineTo(
				xMax * scale + offsetX - headlen * Math.cos(angle + Math.PI / 6),
				yMax * scale + offsetY - headlen * Math.sin(angle + Math.PI / 6)
			);
			ctx.stroke();
		
        } else if (arrowHeadType === 'triangle') {
            // Triangle arrowhead
            ctx.beginPath();
            ctx.moveTo(
                xMax * scale + offsetX - headlen * Math.cos(angle - Math.PI / 6),
                yMax * scale + offsetY - headlen * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(
                xMax * scale + offsetX - headlen * Math.cos(angle + Math.PI / 6),
                yMax * scale + offsetY - headlen * Math.sin(angle + Math.PI / 6)
            );
            ctx.lineTo(xMax * scale + offsetX, yMax * scale + offsetY);
            ctx.closePath();
            ctx.fill();
        }
    }

    // Set font size proportional to the image width
    const fontSize = (labelFontSizePercentage / 100) * originalWidth;
    ctx.font = `${fontSize * scale}px ${labelFont}`;

    // Apply offsets to the label position
    ctx.fillText(name, xMin * scale + offsetX + labelOffsetX, yMin * scale + offsetY + labelOffsetY);
}


// Function to initialize the predefined labels panel
function initPredefinedLabels() {
    var predefinedLabelList = document.getElementById("predefinedLabelList");
    predefinedLabelList.innerHTML = "";  // Clear existing list

    predefinedLabels.forEach(function(label, index) {
        var labelItem = document.createElement("div");
        labelItem.className = "list-group-item";
        labelItem.innerHTML = `
            <div class="input-group">
                <span class="input-group-addon">Label ${index + 1}</span>
                <input type="text" value="${label.name}" class="form-control" onchange="updatePredefinedLabelName(${index}, this.value)">
                <span class="input-group-btn">
                    <input type="color" class="btn btn-default" value="${label.color}" onchange="updatePredefinedLabelColor(${index}, this.value)">
                    <button class="btn btn-danger" onclick="removePredefinedLabel(${index})" type="button">Remove</button>
                </span>
            </div>
        `;
        predefinedLabelList.appendChild(labelItem);
    });
}


// Update the name of a predefined label
function updatePredefinedLabelName(index, newName) {
    predefinedLabels[index].name = newName;
    savePredefinedLabels();  // Save updated labels to localStorage
}

function updatePredefinedLabelColor(index, newColor) {
    predefinedLabels[index].color = newColor;
    savePredefinedLabels();  // Save updated labels to localStorage
}

document.addEventListener('DOMContentLoaded', function() {
    loadLabelFontSizePercentage();
    loadLabelOffsets();
    loadPredefinedLabels();
    loadArrowHeadSize();
    loadArrowHeadType();  // Load arrow head type
    initPredefinedLabels();
});


function setInitialZoom() {
    var cWidth = c.clientWidth;
    var cHeight = c.clientHeight;

    // Calculate the scale factors for both dimensions
    var widthScale = cWidth / originalWidth;
    var heightScale = cHeight / originalHeight;

    // Use the minimum of these scales to fit the image within the container
    var newScale = Math.min(widthScale, heightScale);

    // Update the scale value and slider
    scale = newScale;
    document.getElementById('resizeSlider').value = Math.round(newScale * 100); // Update slider value
    document.getElementById('currentScale').innerText = `${Math.round(newScale * 100)}%`; // Update scale display

    // Set the canvas dimensions and redraw the image and labels
    resizeCanvas();
}

function resizeCanvas() {
    // Keep the canvas dimensions fixed
    c.width = c.clientWidth;
    c.height = c.clientHeight;

    // Clear the canvas before redrawing
    ctx.clearRect(0, 0, c.width, c.height);

    // Calculate the new dimensions of the image based on the scale
    const newWidth = originalWidth * scale;
    const newHeight = originalHeight * scale;

    // Draw the scaled image on the canvas starting from the top-left corner
    ctx.drawImage(image, offsetX, offsetY, newWidth, newHeight);
	
    // Redraw all labels with the new scale and offsets
    labels.forEach(drawLabels);

}

// Dragging logic
var isDragging = false;
var lastX, lastY;

c.addEventListener('mousedown', function(e) {
    if (e.button === 1) { // 1 is the middle mouse button
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        e.preventDefault();
    }
});

c.addEventListener('mousedown', function(e) {
    if (e.button === 1) { // 1 is the middle mouse button
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        e.preventDefault();
    }
});

c.addEventListener('mousemove', function(e) {
    if (isDragging) {
        var dx = e.clientX - lastX;
        var dy = e.clientY - lastY;

        // Update offsets for dragging, using top-left as the origin
        offsetX += dx;
        offsetY += dy;

        // Redraw the image and labels with the updated offsets
        resizeCanvas();

        lastX = e.clientX;
        lastY = e.clientY;
        e.preventDefault();
    }
});

c.addEventListener('mouseup', function(e) {
    if (e.button === 1) {
        isDragging = false;
        e.preventDefault();
    }
});

function updateDebugInfo() {
    var cWidth = c.width;
    var cHeight = c.height;
    var iWidth = image.width * scale;
    var iHeight = image.height * scale;
    // Update debug info here if needed
}

image.onload = function(e) {
    originalWidth = image.width;
    originalHeight = image.height;
    loadPredefinedLabels();  // Ensure predefined labels are loaded for every image
    setInitialZoom(); // Adjust initial zoom
    window.addEventListener('resize', resizeCanvas);
};

document.getElementById('resizeSlider').addEventListener('input', function() {
    scale = this.value / 100;
    document.getElementById('currentScale').innerText = `${this.value}%`;
    resizeCanvas();
});

document.getElementById('resetButton').addEventListener('click', function() {
    scale = 1;
    offsetX = 0;  // Reset horizontal offset
    offsetY = 0;  // Reset vertical offset
    document.getElementById('resizeSlider').value = 100;
    document.getElementById('currentScale').innerText = '100%';
    resizeCanvas();  // Redraw the canvas with the reset values
});


document.getElementById('downloadButton').addEventListener('click', function() {
    // Create a new canvas with the same dimensions as the original image
    var downloadCanvas = document.createElement('canvas');
    downloadCanvas.width = originalWidth;
    downloadCanvas.height = originalHeight;
    var downloadCtx = downloadCanvas.getContext('2d');

    // Draw the image on the new canvas without applying offsets
    downloadCtx.drawImage(image, 0, 0, originalWidth, originalHeight);

    // Draw the labels on the new canvas, ensuring no offsets and scale = 1
    labels.forEach(function(label) {
        drawLabelsOnCanvas(downloadCtx, label, true); // Pass true for download mode
    });

    // Convert the canvas to an image and trigger download
    var link = document.createElement('a');
    link.download = 'image_with_labels.png';
    link.href = downloadCanvas.toDataURL('image/png');
    link.click();
});

// Helper function to draw labels and arrows on a specific canvas context
function drawLabelsOnCanvas(ctx, label, download = false) {
    const { name, xMin, xMax, yMin, yMax, color, type } = label;
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = 3;

    // Use 1 (100%) scale for downloading, otherwise use the current scale
    const effectiveScale = download ? 1 : scale;
    const effectiveOffsetX = download ? 0 : offsetX;
    const effectiveOffsetY = download ? 0 : offsetY;

    if (type === 'box') {
        // Draw a rectangle (bounding box)
        ctx.beginPath();
        ctx.rect(
            xMin * effectiveScale + effectiveOffsetX,
            yMin * effectiveScale + effectiveOffsetY,
            (xMax - xMin) * effectiveScale,
            (yMax - yMin) * effectiveScale
        );
        ctx.stroke();
    } else if (type === 'arrow') {
        // Draw the line of the arrow
        ctx.beginPath();
        ctx.moveTo(
            xMin * effectiveScale + effectiveOffsetX,
            yMin * effectiveScale + effectiveOffsetY
        );
        ctx.lineTo(
            xMax * effectiveScale + effectiveOffsetX,
            yMax * effectiveScale + effectiveOffsetY
        );
        ctx.stroke();

        // Calculate the arrowhead
        const headlen = arrowHeadSize * effectiveScale;
        const angle = Math.atan2(yMax - yMin, xMax - xMin);

        if (arrowHeadType === 'standard') {
            ctx.lineTo(
                xMax * effectiveScale + effectiveOffsetX - headlen * Math.cos(angle - Math.PI / 6),
                yMax * effectiveScale + effectiveOffsetY - headlen * Math.sin(angle - Math.PI / 6)
            );
            ctx.moveTo(xMax * effectiveScale + effectiveOffsetX, yMax * effectiveScale + effectiveOffsetY);
            ctx.lineTo(
                xMax * effectiveScale + effectiveOffsetX - headlen * Math.cos(angle + Math.PI / 6),
                yMax * effectiveScale + effectiveOffsetY - headlen * Math.sin(angle + Math.PI / 6)
            );
            ctx.stroke();
        } else if (arrowHeadType === 'triangle') {
            ctx.beginPath();
            ctx.moveTo(
                xMax * effectiveScale + effectiveOffsetX - headlen * Math.cos(angle - Math.PI / 6),
                yMax * effectiveScale + effectiveOffsetY - headlen * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(
                xMax * effectiveScale + effectiveOffsetX - headlen * Math.cos(angle + Math.PI / 6),
                yMax * effectiveScale + effectiveOffsetY - headlen * Math.sin(angle + Math.PI / 6)
            );
            ctx.lineTo(xMax * effectiveScale + effectiveOffsetX, yMax * effectiveScale + effectiveOffsetY);
            ctx.closePath();
            ctx.fill();
        }
    }

    // Set font size proportional to the image width
    const fontSize = (labelFontSizePercentage / 100) * originalWidth;
    ctx.font = `${fontSize * effectiveScale}px ${labelFont}`;

    // Draw label text
    ctx.fillText(
        name,
        xMin * effectiveScale + effectiveOffsetX + labelOffsetX,
        yMin * effectiveScale + effectiveOffsetY + labelOffsetY
    );
}


function addWheelEventListener(element) {
    element.addEventListener('wheel', function(event) {
        event.preventDefault();
        
        // Determine the zoom direction based on the scroll direction
        var zoomDirection = event.deltaY > 0 ? -1 : 1;
        
        // Adjust the zoom scale
        var zoomFactor = 0.1; // Change this value to adjust zoom sensitivity
        scale += zoomDirection * zoomFactor;
        
        // Keep scale within range
        scale = Math.max(0.1, Math.min(scale, 5)); // Adjust min and max scale as needed
        
        // Update the slider and scale display
        document.getElementById('resizeSlider').value = Math.round(scale * 100);
        document.getElementById('currentScale').innerText = `${Math.round(scale * 100)}%`;
        
        // Resize the canvas to apply the new scale
        resizeCanvas();
    });
}

// Add wheel event listener to #content, #zoomControls, and #sidebar
addWheelEventListener(document.getElementById('content'));
addWheelEventListener(document.getElementById('zoomControls'));
addWheelEventListener(document.getElementById('sidebar'));

var clicked = false;
var fPoint = {};
var labelMode = 'box'; // Default mode is 'box'

document.getElementById('toggleLabelMode').addEventListener('click', function() {
    if (labelMode === 'box') {
        labelMode = 'arrow';
        this.textContent = 'Toggle to Box Mode';
    } else {
        labelMode = 'box';
        this.textContent = 'Toggle to Arrow Mode';
    }
    localStorage.setItem('labelMode', labelMode); // Save labelMode to local storage
});

c.onclick = function(e) {
    var rect = c.getBoundingClientRect();
    var x = (e.clientX - rect.left - offsetX) / scale;  // Adjust for offsetX
    var y = (e.clientY - rect.top - offsetY) / scale;   // Adjust for offsetY

    // Check if the click is inside the image boundaries
    if (x < 0 || y < 0 || x > originalWidth || y > originalHeight) {
        return; // Ignore clicks outside the image
    }

    if (!clicked) {
        ctx.strokeStyle = "red";
        ctx.fillStyle = "red";
        ctx.beginPath();
        ctx.arc((x * scale + offsetX), (y * scale + offsetY), 3, 0, 2 * Math.PI, false);
        ctx.fill();
        fPoint = { x: x, y: y };
        console.log("First click at: ", fPoint);  // Log first click coordinates
    } else {
        var predefinedLabel = predefinedLabels[labels.length % predefinedLabels.length];
        var labelType = (labelMode === 'box') ? 'box' : 'arrow';
        var labelData = {};

        if (labelMode === 'box') {
            var xMin = Math.min(fPoint.x, x);
            var xMax = Math.max(fPoint.x, x);
            var yMin = Math.min(fPoint.y, y);
            var yMax = Math.max(fPoint.y, y);

            // Ensure the bounding box stays within the image boundaries
            xMin = Math.max(xMin, 0);
            yMin = Math.max(yMin, 0);
            xMax = Math.min(xMax, originalWidth);
            yMax = Math.min(yMax, originalHeight);

            labelData = {
                id: (labels.length + 1).toString(),
                name: predefinedLabel.name,
                xMin: xMin,
                xMax: xMax,
                yMin: yMin,
                yMax: yMax,
                color: predefinedLabel.color,
                type: labelType
            };
            labels.push(labelData);
        } else if (labelMode === 'arrow') {
            labelData = {
                id: (labels.length + 1).toString(),
                name: predefinedLabel.name,
                xMin: fPoint.x,  // Start of the arrow
                yMin: fPoint.y,
                xMax: x,         // End of the arrow
                yMax: y,
                color: predefinedLabel.color,
                type: labelType
            };
            labels.push(labelData);
        }

        // Log the label data before sending
        console.log("Sending label data to server: ", labelData);

        // Send the label data to the server
        fetch(`/add/${labelData.id}?xMin=${labelData.xMin}&xMax=${labelData.xMax}&yMin=${labelData.yMin}&yMax=${labelData.yMax}&color=${encodeURIComponent(labelData.color)}&name=${encodeURIComponent(labelData.name)}&type=${labelData.type}`)
            .then(response => {
                if (response.ok) {
                    console.log("Label added successfully:", response);
                } else {
                    console.error("Failed to add label:", response.statusText);
                }
            })
            .catch(error => console.error('Error adding label:', error));

        fPoint = {};  // Clear after use
        resizeCanvas();
        updateLabelList();
    }
    clicked = !clicked;
};


function deleteLabel(id) {
    fetch(`/remove/${id}`)
        .then(response => {
            if (response.ok) {
                labels = labels.filter(label => label.id !== id.toString());
                labels.forEach((label, index) => label.id = (index + 1).toString());
                resizeCanvas();
                updateLabelList();
            } else {
                console.error("Failed to delete label:", response.statusText);
            }
        })
        .catch(error => console.error('Error deleting label:', error));
}

function changeLabelColor(id, newColor) {
    const label = labels.find(label => label.id === id);
    if (label) {
        label.color = newColor;
        fetch(`/label/${id}?color=${encodeURIComponent(newColor)}`)
            .then(response => response.text())
            .then(() => resizeCanvas())
            .catch(error => console.error('Error updating label color:', error));
    }
}

function updateLabelList() {
    var labelList = document.getElementById("labelList");
    labelList.innerHTML = "";
    labels.forEach(function(label, index) {
        var labelItem = document.createElement("div");
        labelItem.className = "list-group-item";  // This class is used initially

        // Creating the exact structure as the initial design
        labelItem.innerHTML = `
            <div class="input-group">
                <span class="input-group-addon" id="id">${label.id}</span>
                <input type="text" value="${label.name}" onchange="changeLabel(${index}, this.value)" class="form-control" style="background-color:#E5E7E9;"></input>
                <span class="input-group-btn">
                    <input type="color" class="btn btn-default" value="${label.color}" onchange="changeLabelColor('${label.id}', this.value)" style="width: 34px; height: 34px; padding: 0; margin: 0 5px;">
                    <button class="btn btn-danger" onclick="deleteLabel('${label.id}')" type="button">-</button>
                </span>
            </div>
        `;
        labelList.appendChild(labelItem);
    });
}


function changeLabel(index, newLabel) {
    labels[index].name = newLabel;
    fetch(`/label/${(index + 1)}?name=${encodeURIComponent(newLabel)}`)
        .then(response => response.text())
        .then(() => {
            resizeCanvas();
            updateLabelList();
        })
        .catch(error => console.error('Error changing label:', error));
}

image.src = "image/{{ image }}";

function saveCSV() {
    let csvContent = "data:text/csv;charset=utf-8,";
    csvContent += "ID,Name,xMin,xMax,yMin,yMax,Color,Type\n";  // Include Type in CSV headers
    labels.forEach(label => {
        let row = `${label.id},${label.name},${label.xMin},${label.xMax},${label.yMin},${label.yMax},${label.color},${label.type}`;
        csvContent += row + "\n";
    });
    
    var encodedUri = encodeURI(csvContent);
    var link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", "labels.csv");
    document.body.appendChild(link);  // Required for FF
    link.click();
    document.body.removeChild(link);
}

document.getElementById('saveCsvButton').addEventListener('click', function() {
    // First, save the current annotations to the annotations.csv file on the server
    fetch('/save')
        .then(response => response.text())
        .then(data => {
            console.log(data);
            // Then, download the current image's annotations as a separate CSV file
            window.location.href = '/download_csv';
        })
        .catch(error => console.error('Error saving CSV:', error));
});

document.getElementById("labelFontSizeInput").addEventListener("input", function() {
    labelFontSizePercentage = parseFloat(this.value); // Update the font size percentage
    localStorage.setItem('labelFontSizePercentage', labelFontSizePercentage); // Save to localStorage
    resizeCanvas();  // Redraw the canvas with the new font size
});

function loadLabelFontSizePercentage() {
    const savedFontSizePercentage = localStorage.getItem('labelFontSizePercentage');
    if (savedFontSizePercentage) {
        labelFontSizePercentage = parseFloat(savedFontSizePercentage);
        document.getElementById("labelFontSizeInput").value = labelFontSizePercentage; // Update the input field
    } else {
        labelFontSizePercentage = 4.5; // Default value
    }
}


document.getElementById("arrowHeadSizeInput").addEventListener("input", function() {
    arrowHeadSize = parseFloat(this.value);
    localStorage.setItem('arrowHeadSize', arrowHeadSize);
});

function loadArrowHeadSize() {
    const savedArrowHeadSize = localStorage.getItem('arrowHeadSize');
    if (savedArrowHeadSize) {
        arrowHeadSize = parseFloat(savedArrowHeadSize);
        document.getElementById("arrowHeadSizeInput").value = arrowHeadSize;
        document.getElementById("arrowHeadSizeSlider").value = arrowHeadSize;
    } else {
        arrowHeadSize = 45; // Default value
    }
}


function resetPredefinedLabelsToDefault() {
    // Reset predefined labels to default
    predefinedLabels = [
        { name: "Apple", color: "#00FFFF" },
        { name: "Banana", color: "#FF00FF" },
        { name: "Peach", color: "#00FF00" },
        { name: "Grapes", color: "#FFFF00" },
        { name: "Lemon", color: "#FF0000" }
    ];

    // Reset label font size to default
    labelFontSizePercentage = 4.5;
    document.getElementById("labelFontSizeInput").value = labelFontSizePercentage;
	
    // Reset arrow head size to default
    arrowHeadSize = 45;
    document.getElementById("arrowHeadSizeInput").value = arrowHeadSize;

    // Reset label offsets to default
    labelOffsetX = 0;
    labelOffsetY = -3;
    document.getElementById("labelOffsetXInput").value = labelOffsetX;
    document.getElementById("labelOffsetYInput").value = labelOffsetY;

    // Reset font to default
    labelFont = "Verdana";
    document.getElementById("fontSelect").value = labelFont;

    // Save the updated defaults to localStorage
    savePredefinedLabels();
    localStorage.setItem('labelFontSizePercentage', labelFontSizePercentage);
    localStorage.setItem('labelOffsetX', labelOffsetX);
    localStorage.setItem('labelOffsetY', labelOffsetY);
    localStorage.setItem('labelFont', labelFont);
    localStorage.setItem('arrowHeadSize', arrowHeadSize);
	
    // Re-initialize the predefined labels panel to reflect the default values
    initPredefinedLabels();

    // Redraw the canvas with the default font size and font
    resizeCanvas();
}


// Add event listener to the "Reset to Default" button
document.getElementById("resetToDefaultPredefinedLabels").addEventListener("click", function() {
    if (confirm("Are you sure you want to reset the predefined labels to their default values?")) {
        resetPredefinedLabelsToDefault();
    }
});
function addPredefinedLabel() {
    predefinedLabels.push({ name: "New Label", color: "#000000" });  // Add a new label with default values
    savePredefinedLabels();  // Save the updated labels to localStorage
    initPredefinedLabels();  // Refresh the predefined labels panel
}

function removePredefinedLabel(index) {
    predefinedLabels.splice(index, 1);  // Remove the label at the specified index
    savePredefinedLabels();  // Save the updated labels to localStorage
    initPredefinedLabels();  // Refresh the predefined labels panel
}

function loadLabelOffsets() {
    const savedOffsetX = localStorage.getItem('labelOffsetX');
    const savedOffsetY = localStorage.getItem('labelOffsetY');

    if (savedOffsetX !== null) {
        labelOffsetX = parseInt(savedOffsetX, 10);
        document.getElementById("labelOffsetXInput").value = labelOffsetX;
    } else {
        labelOffsetX = 0;
    }

    if (savedOffsetY !== null) {
        labelOffsetY = parseInt(savedOffsetY, 10);
        document.getElementById("labelOffsetYInput").value = labelOffsetY;
    } else {
        labelOffsetY = 0;
    }
}

document.getElementById("labelOffsetXInput").addEventListener("input", function() {
    labelOffsetX = parseInt(this.value, 10); // Update horizontal offset
    localStorage.setItem('labelOffsetX', labelOffsetX); // Save to localStorage
    resizeCanvas();  // Redraw the canvas with the new offset
});

document.getElementById("labelOffsetYInput").addEventListener("input", function() {
    labelOffsetY = parseInt(this.value, 10); // Update vertical offset
    localStorage.setItem('labelOffsetY', labelOffsetY); // Save to localStorage
    resizeCanvas();  // Redraw the canvas with the new offset
});
document.getElementById("labelOffsetXInput").addEventListener("input", function() {
    labelOffsetX = parseInt(this.value, 10); // Update horizontal offset
    localStorage.setItem('labelOffsetX', labelOffsetX); // Save to localStorage
    resizeCanvas();  // Redraw the canvas with the new offset
});

document.getElementById("labelOffsetYInput").addEventListener("input", function() {
    labelOffsetY = parseInt(this.value, 10); // Update vertical offset
    localStorage.setItem('labelOffsetY', labelOffsetY); // Save to localStorage
    resizeCanvas();  // Redraw the canvas with the new offset
});


// Add event listener to the "Add New Label" button
document.getElementById("addPredefinedLabel").addEventListener("click", function() {
    addPredefinedLabel();
});

// Sync the slider with the input field
document.getElementById("labelFontSizeSlider").addEventListener("input", function() {
    labelFontSizePercentage = parseFloat(this.value);
    document.getElementById("labelFontSizeInput").value = labelFontSizePercentage;
    localStorage.setItem('labelFontSizePercentage', labelFontSizePercentage);
    resizeCanvas();  // Redraw the canvas with the new font size
});

// Sync the slider with the input field arrowhead
document.getElementById("arrowHeadSizeSlider").addEventListener("input", function() {
    arrowHeadSize = parseFloat(this.value);
    document.getElementById("arrowHeadSizeInput").value = arrowHeadSize;
    localStorage.setItem('arrowHeadSize', arrowHeadSize);
    resizeCanvas();  // Redraw the canvas with the new arrow size
});


// Sync the input field with the slider
document.getElementById("labelFontSizeInput").addEventListener("input", function() {
    labelFontSizePercentage = parseFloat(this.value);
    document.getElementById("labelFontSizeSlider").value = labelFontSizePercentage;
    localStorage.setItem('labelFontSizePercentage', labelFontSizePercentage);
    resizeCanvas();  // Redraw the canvas with the new font size
});

// Sync the input field with the slider
document.getElementById("arrowHeadSizeInput").addEventListener("input", function() {
    arrowHeadSize = parseFloat(this.value);
    document.getElementById("arrowHeadSizeSlider").value = arrowHeadSize;
    localStorage.setItem('arrowHeadSize', arrowHeadSize);
    resizeCanvas();  // Redraw the canvas with the new arrow size
});

</script>

<!-- Include jQuery -->
<script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>

<!-- Include Bootstrap's JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

</body>
</html>
