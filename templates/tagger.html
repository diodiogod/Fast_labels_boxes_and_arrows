<!doctype html>
<html style="height:100%;">
<head>
    <title>Tagger</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/cerulean/bootstrap.min.css" rel="stylesheet"></link>
    <style>
        .hidden {
            visibility: hidden;  /* Hide the content initially */
        }
        
        body {
            margin: 0;
            height: 100%;
            overflow: hidden; /* Prevent scrolling of the body */
			object-position: top left; /* Align the image to the top-left */
            display: flex; /* Make the body a flex container */
}
        }
        #sidebar {
            width: 25%; /* Initial width */
            min-width: 300px; /* Minimum width for the sidebar */
            height: 100%;
            overflow-y: auto;
            float: left;
        }

        #resizer {
            width: 5px;
            height: 100%;
            background-color: #ccc;
            cursor: ew-resize; /* Cursor changes to show it's resizable */
            float: left;
        }

        #content {
            flex-grow: 1;
            height: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }


		#canvas {
			flex-grow: 1;            /* Make canvas grow to fill available space */
			width: 100%;             /* Ensure the canvas takes full width */
			height: 100%;            /* Allow height to adjust based on content */
            max-height: 100%; //(100vh - 40px); /* Ensure it doesn't overflow vertically */
            background-color: white; /* Optional: set a background */
            cursor: crosshair;
            object-fit: contain; /* Ensure the image fits within the canvas */
            object-position: top left; /* Align the image to the top-left */
        }

        #zoomControls {
            position: fixed;
            bottom: 0;
            width: 100%;
            background-color: #f8f9fa; /* Background color for better visibility */
            padding: 10px;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1); /* Optional shadow for better visibility */
            display: flex;
            align-items: center;
            justify-content: space-between; /* Space out the left, slider, and right buttons */
			z-index: 9000;
        }
        
        .left-buttons, .right-buttons {
            display: flex;
            align-items: center;
        }
        
        #resizeSlider {
            flex-grow: 1; /* Allow the slider to grow and fill available space */
            margin: 0 10px; /* Add some margin to give space between the slider and the buttons */
        }
        
        #currentScale {
            margin-right: 10px; /* Space between the scale and the right buttons */
        }
        
		.fixed-bottom-left {
			position: fixed;
			bottom: 10px;
			left: 10px;
			z-index: 10000; /* High z-index to keep buttons on top */
		}
		
        /* Tab styling */
        .nav-tabs {
            margin-bottom: 10px;
        }
        .tab-content {
            height: calc(100% - 40px); /* Adjust to leave space for the tabs */
            overflow-y: auto;
        }
    </style>
</head>
<body class="hidden">
<nav id="sidebar">
    <ul class="nav nav-tabs">
        <li class="active"><a data-toggle="tab" href="#labelsTab">Labels</a></li>
        <li><a data-toggle="tab" href="#predefinedLabelsTab">Predefined Labels</a></li>
    </ul>

    <div class="tab-content">
        <!-- Labels Tab -->
        <div id="labelsTab" class="tab-pane fade in active">
            <div class="panel panel-default" style="height: 100%;">
                <div class="panel-heading">
                    <h3 class="panel-title">Labels</h3>
					<!-- Add this inside the Predefined Labels Tab panel body -->
					<button id="toggleLabelMode" class="btn btn-info" style="width: 100%; margin-top: 10px;">Toggle to Arrow Mode</button>

                </div>
                <div class="panel-body" style="overflow-y: auto;">
                    <div class="list-group" id="labelList">
                        {% for label in labels %}
                            <div class="list-group-item">
                                <div class="input-group">
                                    <span class="input-group-addon" id="id">{{ label.id }}</span>
                                    {% if label.name %}
                                        <input type="text" value="{{ label.name }}" onchange="label('{{ label.id }}', this.value)" class="form-control" style="background-color:#E5E7E9;"></input>
                                        <span class="input-group-btn">
                                            <input type="color" class="btn btn-default" value="{{ label.color }}" onchange="changeLabelColor('{{ label.id }}', this.value)" style="width: 34px; height: 34px; padding: 0; margin-right: 5px; margin-left: 5px;">
                                            <button class="btn btn-danger" onclick="deleteLabel('{{ label.id }}')" type="button">-</button>
                                        </span>
                                    {% else %}
                                        <input id="{{ label.id }}" onkeydown="if (event.keyCode == 13) { label(this.id, this.value); }" type="text" class="form-control" placeholder="label name" autofocus></input>
                                    {% endif %}
                                </div>
                            </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>

        <!-- Predefined Labels Tab -->
		<div id="predefinedLabelsTab" class="tab-pane fade">
			<div class="panel panel-default" style="height: 100%;">
				<div class="panel-heading">
					<h3 class="panel-title">Predefined Labels</h3>
				</div>
				<div class="panel-body" style="overflow-y: auto;">
					<div id="predefinedLabelList" class="list-group">
						<!-- Predefined labels will be listed here -->
					</div>
					
					<!-- First: Label Font Size Input -->
					<label for="labelFontSizeInput">Label Font Size (% of Image Width) and Offset:</label>

					<!-- Label Font Size Slider and Input -->
					<div class="input-group" style="margin-top: 10px;">
						<span class="input-group-addon">Font Size (%):</span>
						<input type="range" id="labelFontSizeSlider" class="form-control" value="4.5" min="1" max="10" step="0.1" style="width: calc(100% - 75px);">
						<input type="number" id="labelFontSizeInput" class="form-control" value="4.5" min="1" max="100" step="0.1" style="width: 75px;">
					</div>
					
					<!-- Unified Label Offset Inputs with Font Selection Dropdown -->
					<div class="input-group" style="margin-top: 10px;">
						<span class="input-group-addon">Offset (X/Y):</span>
						<input type="number" id="labelOffsetXInput" class="form-control" value="0" step="1" style="width: 60px;">
						<input type="number" id="labelOffsetYInput" class="form-control" value="0" step="1" style="width: 60px;">

						<!-- Font Dropdown (Placed in the same input group) -->
						<span class="input-group-addon">Font:</span>
						<select id="fontSelect" class="form-control" style="width: 100%;">
							<option value="Arial">Arial</option>
							<option value="Verdana">Verdana</option>
							<option value="Courier New">Courier New</option>
							<option value="Times New Roman">Times New Roman</option>
							<option value="Georgia">Georgia</option>
							<option value="Roboto">Roboto</option>                <!-- Modern and clean font -->
							<option value="Open Sans">Open Sans</option>          <!-- Popular web font -->
							<option value="Lato">Lato</option>                    <!-- Clean and minimal font -->
							<option value="Consolas">Consolas</option>            <!-- Commonly used in code editors -->
							<option value="Monaco">Monaco</option>                <!-- Another coding font, often used on macOS -->
							<option value="Lucida Console">Lucida Console</option> <!-- Another monospaced font -->
							<option value="Source Code Pro">Source Code Pro</option> <!-- Googleâ€™s font for code -->
							<option value="Fira Code">Fira Code</option>          <!-- A font designed for coding -->
							<option value="PT Mono">PT Mono</option>              <!-- Simple, clear monospaced font -->
							<option value="Inconsolata">Inconsolata</option>      <!-- Another great option for code -->
							<option value="Raleway">Raleway</option>              <!-- Modern and elegant font -->
							<option value="Ubuntu">Ubuntu</option>                <!-- Popular in Linux environments -->
						</select>
					</div>
					
					<!-- Label arrow Size Slider and Input -->
					<div class="input-group" style="margin-top: 10px;">
						<span class="input-group-addon">Arrow Head Size (%):</span>
						<input type="range" id="arrowHeadSizeSlider" class="form-control" value="5" min="0" max="20" step="0.1" style="width: calc(100% - 75px);">
						<input type="number" id="arrowHeadSizeInput" class="form-control" value="5" min="0" max="500" step="0.1" style="width: 75px;">
					</div>
					<!-- Dropdown for selecting Arrowhead Type -->
					<div class="input-group" style="margin-top: 10px;">
						<span class="input-group-addon">Arrowhead Type:</span>
						<select id="arrowHeadTypeSelect" class="form-control">
							<option value="standard">Standard</option>
							<option value="triangle">Triangle</option>
						</select>
					</div>
					
					<!-- Add this inside your predefined labels tab or wherever you have your other sliders -->
					<div class="input-group" style="margin-top: 10px;">
						<span class="input-group-addon">Line Width:</span>
						<input type="range" id="lineWidthSlider" class="form-control" value="1.5" min="0" max="20" step="0.1" style="width: calc(100% - 75px);">
						<input type="number" id="lineWidthInput" class="form-control" value="1.5" min="0" max="500" step="0.1" style="width: 75px;">
					</div>

					<!-- Second: Add New Label Button -->
					<button id="addPredefinedLabel" class="btn btn-success" style="width: 100%; margin-top: 10px;">Add New Label</button>

					<!-- Third: Reset to Default Button -->
					<button id="resetToDefaultPredefinedLabels" class="btn btn-warning" style="width: 100%; margin-top: 10px;">Reset to Default</button>
					
				</div>
			</div>
		</div>

    </div>
</nav>
<div id="resizer"></div>
<div id="content" class="container">

    <div style="overflow: hidden">
        <canvas id="canvas"></canvas>
    </div>
</div>
<div id="zoomControls">
    <div class="left-buttons">
        <a href="/previous" class="btn btn-primary" style="margin-right: 10px;">
            <span class="glyphicon glyphicon-arrow-left"></span>
        </a>
        <a href="/next" class="btn btn-primary">
            <span class="glyphicon glyphicon-arrow-right"></span>
        </a>
    </div>
    <input type="range" id="resizeSlider" min="2.5" max="150" value="100">
    <span id="currentScale">100%</span>

    <div class="right-buttons">
        <button id="resetButton" class="btn btn-primary">Reset to 100%</button>
        <button id="downloadButton" class="btn btn-success" style="margin-left: 10px;">Download Image</button>
        <button id="saveCsvButton" class="btn btn-warning" style="margin-left: 10px;">Save CSV</button>
    </div>
</div>

<script>
var labels = {{ labels|tojson|safe }};
var c = document.getElementById("canvas");
var ctx = c.getContext("2d");
var image = new Image();
var originalWidth, originalHeight;
var scale = 1;
var labelFontSizePercentage = 4.5; // Default value as 4.5%
var arrowHeadSize = 45; // Default value as 45
var labelOffsetX = 0; // Default horizontal offset (in pixels)
var labelOffsetY = 0; // Default vertical offset (in pixels)

var offsetX = 0, offsetY = 0;  // Track offsets for dragging

const resizer = document.getElementById('resizer');
const sidebar = document.getElementById('sidebar');
const content = document.getElementById('content');

resizer.addEventListener('mousedown', function(e) {
    e.preventDefault();

    document.addEventListener('mousemove', resizeSidebar);
    document.addEventListener('mouseup', stopResizing); // Attach the stopResizing listener
});

function resizeSidebar(e) {
    const newSidebarWidth = e.clientX - sidebar.getBoundingClientRect().left;

    if (newSidebarWidth > 200 && newSidebarWidth < window.innerWidth - 200) {
        sidebar.style.width = `${newSidebarWidth}px`;
        content.style.width = `calc(100% - ${newSidebarWidth}px)`;

        // Redraw the canvas after resizing the sidebar
        resizeCanvas();
    }
}

// Add this function to stop resizing when the mouse is released
function stopResizing() {
    document.removeEventListener('mousemove', resizeSidebar);  // Stop the resize action
    document.removeEventListener('mouseup', stopResizing);     // Remove the mouseup listener
}

var predefinedLabels = [
    { name: "Apple", color: "#00FFFF" },
    { name: "Banana", color: "#FF00FF" },
    { name: "Peach", color: "#008000" },
    { name: "Grapes", color: "#FFFF00" },
    { name: "Lemon", color: "#FF0000" }
];  // Add default predefined labels or load them from localStorage

var lineWidth = parseFloat(localStorage.getItem('lineWidth')) || 1.5; // Default line width

// Load the saved line width from local storage
function loadLineWidth() {
    const savedLineWidth = localStorage.getItem('lineWidth');
    if (savedLineWidth !== null) {
        lineWidth = parseFloat(savedLineWidth);
        document.getElementById("lineWidthSlider").value = lineWidth;
        document.getElementById("lineWidthInput").value = lineWidth;
    }
}

// Sync the slider with the input field
document.getElementById("lineWidthSlider").addEventListener("input", function() {
    lineWidth = parseFloat(this.value);
    document.getElementById("lineWidthInput").value = lineWidth;
    localStorage.setItem('lineWidth', lineWidth);
    resizeCanvas();  // Redraw the canvas with the new line width
});

// Sync the input field with the slider
document.getElementById("lineWidthInput").addEventListener("input", function() {
    lineWidth = parseFloat(this.value);
    document.getElementById("lineWidthSlider").value = lineWidth;
    localStorage.setItem('lineWidth', lineWidth);
    resizeCanvas();  // Redraw the canvas with the new line width
});

// Load the saved line width when the document is loaded
document.addEventListener('DOMContentLoaded', function() {
    loadLineWidth();
});

document.addEventListener('DOMContentLoaded', function() {
    const savedSidebarWidth = localStorage.getItem('sidebarWidth');
    const sidebar = document.getElementById('sidebar');
    const content = document.getElementById('content');

    if (savedSidebarWidth) {
        sidebar.style.width = `${savedSidebarWidth}px`;
        content.style.width = `calc(100% - ${savedSidebarWidth}px)`;
    }
        // Set canvas dimensions after the sidebar width is set
        setCanvasDimensions();

        // Show the body only after everything is set
        document.body.classList.remove('hidden');
    });

var labelFont = "Verdana"; // Default font

// Load the font selection from localStorage
function loadFontSelection() {
    const savedFont = localStorage.getItem('labelFont');
    if (savedFont) {
        labelFont = savedFont;
        document.getElementById("fontSelect").value = labelFont;
    } else {
        labelFont = "Verdana"; // Default font
    }
}

// Save the font selection to localStorage
function saveFontSelection() {
    localStorage.setItem('labelFont', labelFont);
}

// Apply the selected font to the labels
function applyFontSelection() {
    // This function will be called whenever the font is changed to redraw the canvas
    resizeCanvas();
}

// Load the font selection when the page loads
document.addEventListener('DOMContentLoaded', function() {
    loadFontSelection();
    applyFontSelection();
});

// Update the font selection when the dropdown value changes
document.getElementById("fontSelect").addEventListener("change", function() {
    labelFont = this.value;
    saveFontSelection();
    applyFontSelection();
});

document.addEventListener('DOMContentLoaded', function() {
    var savedLabelMode = localStorage.getItem('labelMode');
    if (savedLabelMode) {
        labelMode = savedLabelMode;
        document.getElementById('toggleLabelMode').textContent = 
            labelMode === 'box' ? 'Toggle to Arrow Mode' : 'Toggle to Box Mode';
    }
});

// Function to load predefined labels from localStorage or use defaults
function loadPredefinedLabels() {
    const savedPredefinedLabels = localStorage.getItem('predefinedLabels');
    if (savedPredefinedLabels) {
        predefinedLabels = JSON.parse(savedPredefinedLabels);
    } else {
        predefinedLabels = [
            { name: "Apple", color: "#00FF00" },
			{ name: "Apple", color: "#00FFFF" },
			{ name: "Banana", color: "#FF00FF" },
			{ name: "Peach", color: "#008000" },
			{ name: "Grapes", color: "#FFFF00" },
			{ name: "Lemon", color: "#FF0000" }
        ];  // Provide default labels if none are saved
    }
}

// Function to save predefined labels to localStorage
function savePredefinedLabels() {
    localStorage.setItem('predefinedLabels', JSON.stringify(predefinedLabels));
}

// Initialize predefined labels with values from localStorage if available
loadPredefinedLabels();

// Initialize the arrow head type (standard by default)
var arrowHeadType = 'standard';

function loadArrowHeadType() {
    const savedArrowHeadType = localStorage.getItem('arrowHeadType');
    if (savedArrowHeadType) {
        arrowHeadType = savedArrowHeadType;
        document.getElementById("arrowHeadTypeSelect").value = arrowHeadType;
    } else {
        arrowHeadType = 'standard'; // Default type
    }
}

document.getElementById("arrowHeadTypeSelect").addEventListener("change", function() {
    arrowHeadType = this.value;
    localStorage.setItem('arrowHeadType', arrowHeadType);
    resizeCanvas();  // Redraw the canvas with the new arrowhead type
});

// Function to draw labels (both boxes and arrows)
function drawLabels(ctx, label, scale = 1, offsetX = 0, offsetY = 0) {
    const { name, xMin, xMax, yMin, yMax, color, type, xOffset = 0, yOffset = 0 } = label;
    
    // Set label styles
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = ((lineWidth / 100) * originalWidth) * scale;

    if (type === 'box') {
        // Draw a rectangle (bounding box)
        ctx.beginPath();
        ctx.rect(
            (xMin * scale) + offsetX,
            (yMin * scale) + offsetY,
            (xMax - xMin) * scale,
            (yMax - yMin) * scale
        );
        ctx.stroke();
    } else if (type === 'arrow') {
        // Draw the line of the arrow
        // Adjust arrow drawing with scale and offset
        ctx.beginPath();
        ctx.moveTo(
            (xMin * scale) + offsetX,
            (yMin * scale) + offsetY
        );
        ctx.lineTo(
            (xMax * scale) + offsetX,
            (yMax * scale) + offsetY
        );
        ctx.stroke();
        
        // Calculate the arrowhead
        const headlen = ((arrowHeadSize / 100) * originalWidth) * scale; // Scale the arrowhead size
        const angle = Math.atan2(yMax - yMin, xMax - xMin);

        if (arrowHeadType === 'standard') {
            // Standard arrowhead
            ctx.beginPath();
            ctx.moveTo(xMax * scale + offsetX, yMax * scale + offsetY);
            ctx.lineTo(
                xMax * scale + offsetX - headlen * Math.cos(angle - Math.PI / 6),
                yMax * scale + offsetY - headlen * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(xMax * scale + offsetX, yMax * scale + offsetY);
            ctx.lineTo(
                xMax * scale + offsetX - headlen * Math.cos(angle + Math.PI / 6),
                yMax * scale + offsetY - headlen * Math.sin(angle + Math.PI / 6)
            );
            ctx.stroke();
        } else if (arrowHeadType === 'triangle') {
            ctx.beginPath();
            ctx.moveTo(xMax * scale + offsetX, yMax * scale + offsetY);
            ctx.lineTo(
                xMax * scale + offsetX - headlen * Math.cos(angle - Math.PI / 6),
                yMax * scale + offsetY - headlen * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(
                xMax * scale + offsetX - headlen * Math.cos(angle + Math.PI / 6),
                yMax * scale + offsetY - headlen * Math.sin(angle + Math.PI / 6)
            );
            ctx.lineTo(xMax * scale + offsetX, yMax * scale + offsetY);
            ctx.closePath();
            ctx.stroke();
            ctx.fill();
        }
    }

    // Set font size proportional to the image width
    const fontSize = (labelFontSizePercentage / 100) * originalWidth;
    ctx.font = `${fontSize * scale}px ${labelFont}`;
    
    // Scale the offsets based on the original image width
    const finalOffsetX = (labelOffsetX / 1000) * originalWidth * scale + (xOffset * scale);
    const finalOffsetY = (labelOffsetY / 1000) * originalHeight * scale + (yOffset * scale);

    // Apply scaled offsets to the label text position
    ctx.fillText(
        name,
        (xMin * scale) + offsetX + finalOffsetX,  // Apply the combined x offsets
        (yMin * scale) + offsetY + finalOffsetY   // Apply the combined y offsets
    );
}


// Function to initialize the predefined labels panel
function initPredefinedLabels() {
    var predefinedLabelList = document.getElementById("predefinedLabelList");
    predefinedLabelList.innerHTML = "";  // Clear existing list

    predefinedLabels.forEach(function(label, index) {
        var labelItem = document.createElement("div");
        labelItem.className = "list-group-item";
        labelItem.innerHTML = `
            <div class="input-group">
                <input type="text" value="${label.name}" class="form-control" onchange="updatePredefinedLabelName(${index}, this.value)" style="background-color:#E5E7E9;">
                <span class="input-group-btn">
                    <input type="color" class="btn btn-default" value="${label.color}" onchange="updatePredefinedLabelColor(${index}, this.value)" style="width: 34px; height: 34px; padding: 0; margin-right: 5px; margin-left: 5px;">
                    <button class="btn btn-danger" onclick="removePredefinedLabel(${index})" type="button">-</button>
                </span>
            </div>
        `;
        predefinedLabelList.appendChild(labelItem);
    });
}

// Update the name of a predefined label
function updatePredefinedLabelName(index, newName) {
    predefinedLabels[index].name = newName;
    savePredefinedLabels();  // Save updated labels to localStorage
}

function updatePredefinedLabelColor(index, newColor) {
    predefinedLabels[index].color = newColor;
    savePredefinedLabels();  // Save updated labels to localStorage
}

document.addEventListener('DOMContentLoaded', function() {
    loadLabelFontSizePercentage();
    loadLabelOffsets();
    loadPredefinedLabels();
    loadArrowHeadSize();
    loadArrowHeadType();  // Load arrow head type
    initPredefinedLabels();
});


// Function to calculate and set the initial zoom to fit the image in the canvas
function setInitialZoom() {
    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;

    // Calculate scale factors for width and height
    const widthScale = canvasWidth / originalWidth;
    const heightScale = canvasHeight / originalHeight;

    // Use the smaller scale to fit the image in the canvas while maintaining aspect ratio
    scale = Math.min(widthScale, heightScale);

    // Update the zoom slider and scale display
    document.getElementById('resizeSlider').value = Math.round(scale * 100); // Set the slider
    document.getElementById('currentScale').innerText = `${Math.round(scale * 100)}%`; // Display scale
}

// Ensure the canvas dimensions are set properly
function setCanvasDimensions() {
    const container = document.getElementById('content');
    const canvas = document.getElementById('canvas');
    
    // Ensure originalWidth and originalHeight are set
    if (!originalWidth || !originalHeight) {
        console.error("Image dimensions are not available. Make sure the image has loaded.");
        return;
    }

    // Get the container's dimensions
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;

    // Maintain the image aspect ratio
    const aspectRatio = originalWidth / originalHeight;

    if (containerWidth / containerHeight > aspectRatio) {
        canvas.height = containerHeight;
        canvas.width = containerHeight * aspectRatio;
    } else {
        canvas.width = containerWidth;
        canvas.height = containerWidth / aspectRatio;
    }

    // Redraw canvas content after resizing
    resizeCanvas();
}

// Add mouse event listeners to the canvas (after canvas is defined)
let selectedLabel = null;
let isDraggingLabel = false; // Differentiate from general dragging
let dragStartX = 0;
let dragStartY = 0;
let suppressClick = false;  // Flag to suppress clicks after dragging

const DRAG_THRESHOLD = 5; // Threshold in pixels

// Function to detect if a label is clicked
function isLabelClicked(label, x, y, scale, offsetX, offsetY) {
    const fontSize = (labelFontSizePercentage / 100) * originalWidth * scale;
    const labelX = (label.xMin * scale) + offsetX + (label.xOffset * scale);
    const labelY = (label.yMin * scale) + offsetY + (label.yOffset * scale);

    // Check if the click is within the label area (adjust based on font size)
    return (x >= labelX && x <= labelX + fontSize * 5) && (y >= labelY - fontSize && y <= labelY);
}

// Function to add event listeners to handle mouse interactions on the canvas
function addCanvasEventListeners() {
    c.addEventListener('mousedown', (event) => {
        const canvasBounds = c.getBoundingClientRect();
        const mouseX = event.clientX - canvasBounds.left;
        const mouseY = event.clientY - canvasBounds.top;

        labels.forEach(label => {
            if (isLabelClicked(label, mouseX, mouseY, scale, offsetX, offsetY)) {
                selectedLabel = label;
                isDraggingLabel = true;
                dragStartX = mouseX;
                dragStartY = mouseY;
            }
        });
    });

    c.addEventListener('mousemove', (event) => {
        const canvasBounds = c.getBoundingClientRect();
        const mouseX = event.clientX - canvasBounds.left;
        const mouseY = event.clientY - canvasBounds.top;

        let hoveringOverLabel = false;

        // Check if the mouse is hovering over any label
        labels.forEach(label => {
            if (isLabelClicked(label, mouseX, mouseY, scale, offsetX, offsetY)) {
                hoveringOverLabel = true;
            }
        });

        // Change cursor style if hovering over a label
        if (hoveringOverLabel) {
            c.style.cursor = 'pointer';
        } else {
            c.style.cursor = 'crosshair';
        }

        // Handle dragging logic
        if (isDraggingLabel && selectedLabel) {
            const deltaX = (mouseX - dragStartX) / scale;
            const deltaY = (mouseY - dragStartY) / scale;

            // Ensure offsets are treated as numbers during dragging
            selectedLabel.xOffset = parseFloat(selectedLabel.xOffset) + deltaX;
            selectedLabel.yOffset = parseFloat(selectedLabel.yOffset) + deltaY;

            dragStartX = mouseX;
            dragStartY = mouseY;

            resizeCanvas(); // Redraw canvas with updated label position
        }
    });

    c.addEventListener('mouseup', (event) => {
        if (isDraggingLabel && selectedLabel) {
            isDraggingLabel = false;

            // Save updated label offsets to the server
            fetch(`/label/${selectedLabel.id}?xOffset=${selectedLabel.xOffset}&yOffset=${selectedLabel.yOffset}`)
                .then(response => response.text())
                .then(data => console.log("Label offsets updated:", data))
                .catch(error => console.error("Error updating label offsets:", error));

            selectedLabel = null;
            suppressClick = true;  // Suppress click after dragging
            resizeCanvas();  // Redraw with the updated offsets
        }
    });

    window.addEventListener('resize', setCanvasDimensions);
}

// Function to create a new label and attach it to the labels array
function createNewLabel(labelData) {
    labels.push(labelData); // Add the new label to the array

    // Draw the new label immediately
    drawLabels(ctx, labelData, scale, offsetX, offsetY);

    // Redraw canvas to ensure everything is updated
    resizeCanvas();

    // Ensure the label is draggable immediately after creation
    suppressClick = true; // Prevent the label from being created twice due to mouse events
}

// Ensure the canvas event listeners are attached after the DOM loads
document.addEventListener('DOMContentLoaded', () => {
    addCanvasEventListeners();  // Attach all necessary event listeners
});

// Example label creation function
function createLabel(xMin, yMin, xMax, yMax, color, name) {
    const newLabel = {
        id: (labels.length + 1).toString(),
        name: name,
        xMin: xMin,
        yMin: yMin,
        xMax: xMax,
        yMax: yMax,
        color: color,
        xOffset: 0,
        yOffset: 0,
        type: 'box'  // Example type
    };

    // Create the label and make it draggable immediately
    createNewLabel(newLabel);
}



window.addEventListener('resize', setCanvasDimensions);
setCanvasDimensions();

// Function to initialize the canvas and draw the image and labels
function resizeCanvas() {
    const ctx = canvas.getContext('2d');

    // Ensure the canvas fills the entire available space
    canvas.width = canvas.parentElement.clientWidth;
    canvas.height = canvas.parentElement.clientHeight;

    // Clear the canvas before redrawing
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Check if the image is loaded and draw it
    if (image.complete && originalWidth && originalHeight) {
        // Calculate the scaled dimensions of the image
        const newWidth = originalWidth * scale;
        const newHeight = originalHeight * scale;

        // Draw the image on the canvas
        ctx.drawImage(image, offsetX, offsetY, newWidth, newHeight);

        // Redraw labels (boxes/arrows) on top of the image
        labels.forEach(function(label) {
            drawLabels(ctx, label, scale, offsetX, offsetY);
        });
    } else {
        console.error("Image not loaded yet.");
    }
}

// Dragging logic
var isDragging = false;
var lastX, lastY;

c.addEventListener('mousedown', function(e) {
    if (e.button === 1) { // 1 is the middle mouse button
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        e.preventDefault();
    }
});

c.addEventListener('mousemove', function(e) {
    if (isDragging) {
        var dx = e.clientX - lastX;
        var dy = e.clientY - lastY;

        // Update offsets for dragging, using top-left as the origin
        offsetX += dx;
        offsetY += dy;

        // Redraw the image and labels with the updated offsets
        resizeCanvas();

        lastX = e.clientX;
        lastY = e.clientY;
        e.preventDefault();
    }
});

c.addEventListener('mouseup', function(e) {
    if (e.button === 1) {
        isDragging = false;
        e.preventDefault();
    }
});

function updateDebugInfo() {
    var cWidth = c.width;
    var cHeight = c.height;
    var iWidth = image.width * scale;
    var iHeight = image.height * scale;
    // Update debug info here if needed
}

function initializeCanvasWithImage(image) {
    originalWidth = image.width;
    originalHeight = image.height;
    loadPredefinedLabels();  // Ensure predefined labels are loaded for every image
    setInitialZoom(); // Adjust initial zoom
    window.addEventListener('resize', resizeCanvas);
}

image.onload = function() {
    originalWidth = image.width;
    originalHeight = image.height;
    // Set canvas dimensions based on the loaded image
    setCanvasDimensions();
    
    // Calculate the initial zoom scale to fit the image within the canvas
    setInitialZoom();

    // Draw the image on the canvas for the first time
    resizeCanvas();
};

document.getElementById('resizeSlider').addEventListener('input', function() {
    scale = this.value / 100;
    document.getElementById('currentScale').innerText = `${this.value}%`;
    resizeCanvas();
});

document.getElementById('resetButton').addEventListener('click', function() {
    scale = 1;
    offsetX = 0;  // Reset horizontal offset
    offsetY = 0;  // Reset vertical offset
    document.getElementById('resizeSlider').value = 100;
    document.getElementById('currentScale').innerText = '100%';
    resizeCanvas();  // Redraw the canvas with the reset values
});


document.getElementById('downloadButton').addEventListener('click', function() {
    // Create a new canvas with the same dimensions as the original image
    var downloadCanvas = document.createElement('canvas');
    downloadCanvas.width = originalWidth;
    downloadCanvas.height = originalHeight;
    var downloadCtx = downloadCanvas.getContext('2d');

    // Draw the image on the new canvas without applying offsets
    downloadCtx.drawImage(image, 0, 0, originalWidth, originalHeight);

    labels.forEach(function (label) {
        drawLabels(downloadCtx, label, 1, 0, 0); // No scale or offset for download
    });

    // Convert the canvas to an image and trigger download
    var link = document.createElement('a');
    link.download = 'image_with_labels.png';
    link.href = downloadCanvas.toDataURL('image/png');
    link.click();
});

function addWheelEventListener(element) {
    element.addEventListener('wheel', function(event) {
        event.preventDefault();
        
        // Determine the zoom direction based on the scroll direction
        var zoomDirection = event.deltaY > 0 ? -1 : 1;
        
        // Adjust the zoom scale
        var zoomFactor = 0.075; // Change this value to adjust zoom sensitivity
        scale += zoomDirection * zoomFactor;
        
        // Keep scale within range
        scale = Math.max(0.025, Math.min(scale, 8)); // Adjust min and max scale as needed
        
        // Update the slider and scale display
        document.getElementById('resizeSlider').value = Math.round(scale * 100);
        document.getElementById('currentScale').innerText = `${Math.round(scale * 100)}%`;
        
        // Resize the canvas to apply the new scale
        resizeCanvas();
    });
}

// Add wheel event listener to #content, #zoomControls, and #sidebar
addWheelEventListener(document.getElementById('content'));
addWheelEventListener(document.getElementById('zoomControls'));
// addWheelEventListener(document.getElementById('sidebar'));

var clicked = false;
var fPoint = {};
var labelMode = 'box'; // Default mode is 'box'

document.getElementById('toggleLabelMode').addEventListener('click', function() {
    if (labelMode === 'box') {
        labelMode = 'arrow';
        this.textContent = 'Toggle to Box Mode';
    } else {
        labelMode = 'box';
        this.textContent = 'Toggle to Arrow Mode';
    }
    localStorage.setItem('labelMode', labelMode); // Save labelMode to local storage
});

function getAdjustedCoordinates(e) {
    var rect = c.getBoundingClientRect();  // Get canvas dimensions relative to viewport

    // Calculate the correct coordinates by adjusting for canvas position, offsets, and scale
    var x = (e.clientX - rect.left - offsetX) / scale;
    var y = (e.clientY - rect.top - offsetY) / scale;

    return { x, y };
}

c.onclick = function(e) {
    // If suppressClick is true, reset it and return to avoid creating a new label
    if (suppressClick) {
        suppressClick = false;
        return;
    }
	
    const { x, y } = getAdjustedCoordinates(e);

    // Check if the click is inside the image boundaries
    if (x < 0 || y < 0 || x > originalWidth || y > originalHeight) {
        return; // Ignore clicks outside the image
    }

    if (!clicked) {
        ctx.strokeStyle = "red";
        ctx.fillStyle = "red";
        ctx.beginPath();
        ctx.arc((x * scale + offsetX), (y * scale + offsetY), 3, 0, 2 * Math.PI, false);
        ctx.fill();
        fPoint = { x: x, y: y };
        console.log("First click at: ", fPoint);  // Log first click coordinates
    } else {
        var predefinedLabel = predefinedLabels[labels.length % predefinedLabels.length];
        var labelType = (labelMode === 'box') ? 'box' : 'arrow';
        var labelData = {};

        if (labelMode === 'box') {
            var xMin = Math.min(fPoint.x, x);
            var xMax = Math.max(fPoint.x, x);
            var yMin = Math.min(fPoint.y, y);
            var yMax = Math.max(fPoint.y, y);

            // Ensure the bounding box stays within the image boundaries
            xMin = Math.max(xMin, 0);
            yMin = Math.max(yMin, 0);
            xMax = Math.min(xMax, originalWidth);
            yMax = Math.min(yMax, originalHeight);

            labelData = {
                id: (labels.length + 1).toString(),
                name: predefinedLabel.name,
                xMin: xMin,
                xMax: xMax,
                yMin: yMin,
                yMax: yMax,
                color: predefinedLabel.color,
                type: labelType,
                xOffset: 0,  // Initialize offsets
                yOffset: 0
            };
        } else if (labelMode === 'arrow') {
            labelData = {
                id: (labels.length + 1).toString(),
                name: predefinedLabel.name,
                xMin: fPoint.x,  // Start of the arrow
                yMin: fPoint.y,
                xMax: x,         // End of the arrow
                yMax: y,
                color: predefinedLabel.color,
                type: labelType,
                xOffset: 0,  // Initialize offsets
                yOffset: 0
            };
        }

        labels.push(labelData);


        // Log the label data before sending
        //console.log("Sending label data to server: ", labelData);
		
		console.log("Adjusted Click Coordinates: ", { x, y });
		
        // Draw the label immediately using the updated drawLabels function
        drawLabels(ctx, labelData, scale, offsetX, offsetY);

        // Redraw canvas to ensure everything is updated
        resizeCanvas();
	

        // Send the label data to the server
        fetch(`/add/${labelData.id}?xMin=${labelData.xMin}&xMax=${labelData.xMax}&yMin=${labelData.yMin}&yMax=${labelData.yMax}&color=${encodeURIComponent(labelData.color)}&name=${encodeURIComponent(labelData.name)}&type=${labelData.type}`)
            .then(response => {
                if (response.ok) {
                    console.log("Label added successfully:", response);
                } else {
                    console.error("Failed to add label:", response.statusText);
                }
            })
            .catch(error => console.error('Error adding label:', error));

        fPoint = {};  // Clear after use
        updateLabelList();
    }
    clicked = !clicked;
};

function deleteLabel(id) {
    fetch(`/remove/${id}`)
        .then(response => {
            if (response.ok) {
                labels = labels.filter(label => label.id !== id.toString());
                labels.forEach((label, index) => label.id = (index + 1).toString());
                resizeCanvas();
                updateLabelList();
            } else {
                console.error("Failed to delete label:", response.statusText);
            }
        })
        .catch(error => console.error('Error deleting label:', error));
}

function changeLabelColor(id, newColor) {
    const label = labels.find(label => label.id === id);
    if (label) {
        label.color = newColor;
        fetch(`/label/${id}?color=${encodeURIComponent(newColor)}`)
            .then(response => response.text())
            .then(() => resizeCanvas())
            .catch(error => console.error('Error updating label color:', error));
    }
}

function updateLabelList() {
    var labelList = document.getElementById("labelList");
    labelList.innerHTML = "";
    labels.forEach(function(label, index) {
        var labelItem = document.createElement("div");
        labelItem.className = "list-group-item";  // This class is used initially

        // Creating the exact structure as the initial design
        labelItem.innerHTML = `
            <div class="input-group">
                <span class="input-group-addon" id="id">${label.id}</span>
                <input type="text" value="${label.name}" onchange="changeLabel(${index}, this.value)" class="form-control" style="background-color:#E5E7E9;"></input>
                <span class="input-group-btn">
                    <input type="color" class="btn btn-default" value="${label.color}" onchange="changeLabelColor('${label.id}', this.value)" style="width: 34px; height: 34px; padding: 0; margin: 0 5px;">
                    <button class="btn btn-danger" onclick="deleteLabel('${label.id}')" type="button">-</button>
                </span>
            </div>
        `;
        labelList.appendChild(labelItem);
    });
}


function changeLabel(index, newLabel) {
    labels[index].name = newLabel;
    fetch(`/label/${(index + 1)}?name=${encodeURIComponent(newLabel)}`)
        .then(response => response.text())
        .then(() => {
            resizeCanvas();
            updateLabelList();
        })
        .catch(error => console.error('Error changing label:', error));
}

image.src = "image/{{ image }}";

function saveCSV() {
    let csvContent = "data:text/csv;charset=utf-8,";
    csvContent += "ID,Name,xMin,xMax,yMin,yMax,Color,Type\n";  // Include Type in CSV headers
    labels.forEach(label => {
        let row = `${label.id},${label.name},${label.xMin},${label.xMax},${label.yMin},${label.yMax},${label.color},${label.type}`;
        csvContent += row + "\n";
    });
    
    var encodedUri = encodeURI(csvContent);
    var link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", "labels.csv");
    document.body.appendChild(link);  // Required for FF
    link.click();
    document.body.removeChild(link);
}

document.getElementById('saveCsvButton').addEventListener('click', function() {
    // First, save the current annotations to the annotations.csv file on the server
    fetch('/save')
        .then(response => response.text())
        .then(data => {
            console.log(data);
            // Then, download the current image's annotations as a separate CSV file
            window.location.href = '/download_csv';
        })
        .catch(error => console.error('Error saving CSV:', error));
});

document.getElementById("labelFontSizeInput").addEventListener("input", function() {
    labelFontSizePercentage = parseFloat(this.value); // Update the font size percentage
    localStorage.setItem('labelFontSizePercentage', labelFontSizePercentage); // Save to localStorage
    resizeCanvas();  // Redraw the canvas with the new font size
});

function loadLabelFontSizePercentage() {
    const savedFontSizePercentage = localStorage.getItem('labelFontSizePercentage');
    if (savedFontSizePercentage) {
        labelFontSizePercentage = parseFloat(savedFontSizePercentage);
        document.getElementById("labelFontSizeInput").value = labelFontSizePercentage; // Update the input field
    } else {
        labelFontSizePercentage = 4.5; // Default value
    }
}


document.getElementById("arrowHeadSizeInput").addEventListener("input", function() {
    arrowHeadSize = parseFloat(this.value);
    localStorage.setItem('arrowHeadSize', arrowHeadSize);
});

function loadArrowHeadSize() {
    const savedArrowHeadSize = localStorage.getItem('arrowHeadSize');
    if (savedArrowHeadSize) {
        arrowHeadSize = parseFloat(savedArrowHeadSize);
        document.getElementById("arrowHeadSizeInput").value = arrowHeadSize;
        document.getElementById("arrowHeadSizeSlider").value = arrowHeadSize;
    } else {
        arrowHeadSize = 45; // Default value
    }
}


function resetPredefinedLabelsToDefault() {
    // Reset predefined labels to default
    predefinedLabels = [
        { name: "Apple", color: "#00FFFF" },
        { name: "Banana", color: "#FF00FF" },
        { name: "Peach", color: "#00FF00" },
        { name: "Grapes", color: "#FFFF00" },
        { name: "Lemon", color: "#FF0000" }
    ];

    // Reset label font size to default
    labelFontSizePercentage = 4.5;
    document.getElementById("labelFontSizeInput").value = labelFontSizePercentage;
	
    // Reset arrow head size to default
    arrowHeadSize = 45;
    document.getElementById("arrowHeadSizeInput").value = arrowHeadSize;

    // Reset label offsets to default
    labelOffsetX = 0;
    labelOffsetY = -3;
    document.getElementById("labelOffsetXInput").value = labelOffsetX;
    document.getElementById("labelOffsetYInput").value = labelOffsetY;

    // Reset font to default
    labelFont = "Verdana";
    document.getElementById("fontSelect").value = labelFont;

    // Save the updated defaults to localStorage
    savePredefinedLabels();
    localStorage.setItem('labelFontSizePercentage', labelFontSizePercentage);
    localStorage.setItem('labelOffsetX', labelOffsetX);
    localStorage.setItem('labelOffsetY', labelOffsetY);
    localStorage.setItem('labelFont', labelFont);
    localStorage.setItem('arrowHeadSize', arrowHeadSize);
	
    // Re-initialize the predefined labels panel to reflect the default values
    initPredefinedLabels();

    // Redraw the canvas with the default font size and font
    resizeCanvas();
}


// Add event listener to the "Reset to Default" button
document.getElementById("resetToDefaultPredefinedLabels").addEventListener("click", function() {
    if (confirm("Are you sure you want to reset the predefined labels to their default values?")) {
        resetPredefinedLabelsToDefault();
    }
});
function addPredefinedLabel() {
    predefinedLabels.push({ name: "New Label", color: "#000000" });  // Add a new label with default values
    savePredefinedLabels();  // Save the updated labels to localStorage
    initPredefinedLabels();  // Refresh the predefined labels panel
}

function removePredefinedLabel(index) {
    predefinedLabels.splice(index, 1);  // Remove the label at the specified index
    savePredefinedLabels();  // Save the updated labels to localStorage
    initPredefinedLabels();  // Refresh the predefined labels panel
}

function loadLabelOffsets() {
    const savedOffsetX = localStorage.getItem('labelOffsetX');
    const savedOffsetY = localStorage.getItem('labelOffsetY');

    if (savedOffsetX !== null) {
        labelOffsetX = parseInt(savedOffsetX, 10);
        document.getElementById("labelOffsetXInput").value = labelOffsetX;
    } else {
        labelOffsetX = 0;
    }

    if (savedOffsetY !== null) {
        labelOffsetY = parseInt(savedOffsetY, 10);
        document.getElementById("labelOffsetYInput").value = labelOffsetY;
    } else {
        labelOffsetY = 0;
    }
}

function handleOffsetInput(axis) {
    return function() {
        const value = parseInt(this.value, 10);
        if (axis === 'X') {
            labelOffsetX = value;
            localStorage.setItem('labelOffsetX', labelOffsetX);
        } else if (axis === 'Y') {
            labelOffsetY = value;
            localStorage.setItem('labelOffsetY', labelOffsetY);
        }
        resizeCanvas();  // Redraw the canvas with the new offset
    };
}

document.getElementById("labelOffsetXInput").addEventListener("input", handleOffsetInput('X'));
document.getElementById("labelOffsetYInput").addEventListener("input", handleOffsetInput('Y'));


// Add event listener to the "Add New Label" button
document.getElementById("addPredefinedLabel").addEventListener("click", function() {
    addPredefinedLabel();
});

// Sync the slider with the input field
document.getElementById("labelFontSizeSlider").addEventListener("input", function() {
    labelFontSizePercentage = parseFloat(this.value);
    document.getElementById("labelFontSizeInput").value = labelFontSizePercentage;
    localStorage.setItem('labelFontSizePercentage', labelFontSizePercentage);
    resizeCanvas();  // Redraw the canvas with the new font size
});

// Sync the slider with the input field arrowhead
document.getElementById("arrowHeadSizeSlider").addEventListener("input", function() {
    arrowHeadSize = parseFloat(this.value);
    document.getElementById("arrowHeadSizeInput").value = arrowHeadSize;
    localStorage.setItem('arrowHeadSize', arrowHeadSize);
    resizeCanvas();  // Redraw the canvas with the new arrow size
});


// Sync the input field with the slider
document.getElementById("labelFontSizeInput").addEventListener("input", function() {
    labelFontSizePercentage = parseFloat(this.value);
    document.getElementById("labelFontSizeSlider").value = labelFontSizePercentage;
    localStorage.setItem('labelFontSizePercentage', labelFontSizePercentage);
    resizeCanvas();  // Redraw the canvas with the new font size
});

// Sync the input field with the slider
document.getElementById("arrowHeadSizeInput").addEventListener("input", function() {
    arrowHeadSize = parseFloat(this.value);
    document.getElementById("arrowHeadSizeSlider").value = arrowHeadSize;
    localStorage.setItem('arrowHeadSize', arrowHeadSize);
    resizeCanvas();  // Redraw the canvas with the new arrow size
});

</script>

<!-- Include jQuery -->
<script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>

<!-- Include Bootstrap's JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

</body>
</html>
